"0",""
"0","class Schedule:"
"0","    def __init__(self, x, d, s, q, omega):"
"0","        if not all(isinstance(i, np.integer) and i >= 0 for i in x):"
"0","            raise ValueError(""All elements in x must be non-negative integers."")"
"0","        if not isinstance(d, int) or d <= 0:"
"0","            raise ValueError(""d must be a positive integer."")"
"0","        if not all(isinstance(i, float) and 0 <= i <= 1 for i in s):"
"0","            raise ValueError(""All elements in s must be floats between 0 and 1."")"
"0","        if not isinstance(q, float) and 0 <= q <= 1:"
"0","            raise ValueError(""q must be a float between 0 and 1."")"
"0","        if not isinstance(omega, float) and 0 <= omega <= 1:"
"0","            raise ValueError(""omegea must be a float between 0 and 1."")"
"0","            "
"0","        self.parameters = {'x': x, 'd': d, 's': s, 'q': q, 'omega': omega}"
"0","        self.parameters['s'] = service_time_with_no_shows(self.parameters['s'], self.parameters['q'])"
"0","        self._initialize_system()"
"0","        "
"0","    def _initialize_system(self):"
"0","        self.state = 0"
"0","        self.system = {"
"0","            'p_min': [],  # Initialize as empty list"
"0","            'p_plus': [],  # Initialize as empty list"
"0","            'w': [[] for _ in self.parameters['x']],  # Initialize as list of lists"
"0","            'ew': [],  # Initialize as empty list"
"0","            'loss': None,"
"0","            'search_path': [] # Initialize as empty list"
"0","        }"
"0","        self.system['p_min'].append(np.zeros(len(self.parameters['s']), dtype=np.float64))"
"0","        self.system['p_min'][0][0] = 1  # The first patient in the schedule has waiting time zero with probability 1"
"0","        if self.parameters['x'][0] > 0:  # Only calculate waiting times if there are patients scheduled in the state"
"0","            self.system['w'][0].append(self.system['p_min'][0].copy())"
"0","            for i in range(1, self.parameters['x'][0]):"
"0","                convolved = np.convolve(self.system['w'][0][i-1], self.parameters['s'])"
"0","                self.system['w'][0].append(convolved)"
"0","        self._update_p_plus(0)"
"0","        self.state = 1"
"0","        "
"0","    def _update_p_plus(self, state):"
"0","        if self.parameters['x'][state] == 0:"
"0","            self.system['p_plus'].append(self.system['p_min'][state].copy())"
"0","        else:"
"0","            convolved = np.convolve(self.system['w'][state][-1], self.parameters['s'], mode='full')"
"0","            self.system['p_plus'].append(convolved)"
"0","        logging.info(f""p_plus = {self.system['p_plus'][state]}"")"
"0","        "
"0","    def _calculate_state(self):"
"0","        logging.info(f'{datetime.datetime.now()} - State = {self.state}')"
"0","        new_p_min_length = len(self.system['p_plus'][self.state-1]) - self.parameters['d']"
"0","        new_p_min = np.zeros(max(len(self.system['p_plus'][self.state-1]), new_p_min_length + self.parameters['d']), dtype=np.float64)"
"0","        new_p_min[0] = np.sum(self.system['p_plus'][self.state-1][:(self.parameters['d'] + 1)])"
"0","        new_p_min[1:new_p_min_length] = self.system['p_plus'][self.state-1][(self.parameters['d'] + 1):]"
"0","        self.system['p_min'].append(new_p_min)"
"0","        if self.parameters['x'][self.state] > 0:"
"0","            self.system['w'][self.state].append(self.system['p_min'][self.state].copy())"
"0","            logging.info(self.system['w'][self.state][0])"
"0","            for i in range(1, self.parameters['x'][self.state]):"
"0","                convolved = np.convolve(self.system['w'][self.state][i-1], self.parameters['s'])"
"0","                self.system['w'][self.state].append(convolved)"
"0","                logging.info(self.system['w'][self.state][i])"
"0","        self._update_p_plus(self.state)"
"0","        "
"0","    def calculate_system_states(self, until=1):"
"0","        while self.state < until:"
"0","            self._calculate_state()"
"0","            self.state += 1"
"0","            "
"0","    def calculate_tardiness(self):"
"0","        new_p_min_length = len(self.system['p_plus'][-1]) + self.parameters['d']"
"0","        new_p_min = np.zeros(new_p_min_length, dtype=np.float64)"
"0","        new_p_min[0] = np.sum(self.system['p_plus'][-1][:(self.parameters['d'] + 1)])"
"0","        new_p_min[1:len(self.system['p_plus'][-1]) - self.parameters['d']] = self.system['p_plus'][-1][(self.parameters['d'] + 1):]"
"0","        self.system['p_min'][-1] = new_p_min"
"0","        "
"0","    def calculate_wait_times(self):"
"0","        for interval, wtdists in enumerate(self.system['w']):"
"0","            ew = 0"
"0","            for nr, dist in enumerate(wtdists):"
"0","                a = range(len(dist))"
"0","                b = dist"
"0","                meanwt = np.dot(a, b)"
"0","                logging.info(f""Mean waiting time for patient {nr} in interval {interval} = {meanwt}"")"
"0","                ew += meanwt"
"0","            self.system['ew'].append(ew)"
"0","            "
"0","    def calculate_loss(self):"
"0","        omega = self.parameters['omega']"
"0","        tot_wt = np.sum(self.system[""ew""])"
"0","        self.calculate_tardiness()"
"0","        indices = np.arange(len(self.system['p_min'][-1])) "
"0","        exp_tard = (indices * self.system['p_min'][-1]).sum()"
"0","        self.system['loss'] = omega * tot_wt / sum(self.parameters['x']) + (1 - omega) * exp_tard"
"0","            "
"0","    def local_search(self, omega=0.5):"
"0","        omega = self.parameters['omega']"
"0","        # Calculate initial loss"
"0","        test_wt = np.sum(self.system[""ew""])  # Use np.sum instead of list's sum method"
"0","        self.calculate_tardiness()"
"0","        indices = np.arange(self.system['p_min'][-1].size) "
"0","        exp_tard = (indices * self.system['p_min'][-1]).sum()"
"0","        lowest_loss = omega * test_wt / np.sum(self.parameters['x']) + (1 - omega) * exp_tard"
"0","        store_optim = {'x': self.parameters['x'].copy(), 'system': copy.deepcopy(self.system), 'tot_wt': test_wt}"
"0","    "
"0","        # Initialize search path"
"0","        search_path = []"
"0","    "
"0","        # Save initial schedule and loss"
"0","        search_path.append({'schedule': self.parameters['x'].copy(), 'loss': lowest_loss})"
"0","        "
"0","        # Continue the search until no improvement is found"
"0","        while True:  # Start an outer loop that will continue until explicitly broken"
"0","            nh = generate_search_neighborhood(self.parameters['x'])  # Generate a new neighborhood"
"0","            improved = False  # Flag to check if an improvement was found in the inner loop"
"0","            "
"0","            for y in nh:  # Inner loop to search through the neighborhood"
"0","                self.parameters['x'] = y.copy()"
"0","                logging.info(f""Test schedule = {self.parameters['x']}"")"
"0","                self.state = 0"
"0","                self._initialize_system()"
"0","                self.calculate_system_states(until=len(self.parameters['x']))"
"0","                logging.info(""System recalculated"")"
"0","                self.calculate_wait_times()"
"0","                test_wt = np.sum(self.system[""ew""])  # Use np.sum instead of list's sum method"
"0","                logging.info(f""Average waiting time={test_wt / np.sum(self.parameters['x'])}"")"
"0","                self.calculate_tardiness()"
"0","                indices = np.arange(self.system['p_min'][-1].size) "
"0","                exp_tard = (indices * self.system['p_min'][-1]).sum()"
"0","                logging.info(f'Expected tardiness={exp_tard}')"
"0","                test_loss = omega * test_wt / np.sum(self.parameters['x']) + (1 - omega) * exp_tard"
"0","                logging.info(f'obj_value = {test_loss}')"
"0","                search_path.append({'schedule': self.parameters['x'].copy(), 'loss': test_loss})  # Save current schedule and loss"
"0","                if test_loss < lowest_loss:"
"0","                    lowest_loss = test_loss"
"0","                    store_optim['x'] = self.parameters['x'].copy()"
"0","                    newsystem = copy.deepcopy(self.system)"
"0","                    store_optim['system'] = newsystem"
"0","                    store_optim['tot_wt'] = test_wt"
"0","                    logging.info(f'{datetime.datetime.now()} - Found lower loss = {lowest_loss} with x = {store_optim[""x""]} and system = {store_optim[""system""]}')"
"0","                    improved = True"
"0","                    break  # Exit the inner loop to generate a new neighborhood"
"0","            "
"0","            if not improved:  # If no improvement was found in the inner loop"
"0","                logging.info(f'Finished searching')"
"0","                self.parameters['x'] = store_optim['x'].copy()"
"0","                self.system['p_min'] = store_optim['system']['p_min']"
"0","                self.system['p_plus'] = store_optim['system']['p_plus']"
"0","                self.system['w'] = store_optim['system']['w']"
"0","                self.system['ew'] = store_optim['system']['ew']"
"0","                self.system['search_path'] = search_path"
"0","                break  # Exit the outer loop - the search is complete"
"0","        "
"0","    def __str__(self):"
"0","        return ""p_min = % s \nw = % s \np_plus = % s \new = % s \ntardiness = % s \nloss = % s"" % (self.system['p_min'], self.system['w'], self.system['p_plus'], self.system['ew'], self.system['p_min'][-1], self.system['loss'])"
"0","        "
"0","# Example usage:"
"0","x = np.array([2, 1, 0])"
"0","d = 3"
"0","s = [0.1, 0.3, 0.25, 0.2, 0.15]"
"0","q = 0.0"
"0","omega = 0.5"
"0",""
"0","schedule = Schedule(x, d, s, q, omega)"
"0","print(schedule)"
"1","p_min = [array([1., 0., 0., 0., 0.])] 
w = [[array([1., 0., 0., 0., 0.]), array([0.1 , 0.3 , 0.25, 0.2 , 0.15, 0.  , 0.  , 0.  , 0.  ])], [], []] 
p_plus = [array([0.01  , 0.06  , 0.14  , 0.19  , 0.2125, 0.19  , 0.115 , 0.06  ,
       0.0225, 0.    , 0.    , 0.    , 0.    ])] 
ew = [] 
tardiness = [1. 0. 0. 0. 0.] 
loss = None
"
