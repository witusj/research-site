"0","import logging"
"0","import copy"
"0","import datetime"
"0","import numpy as np"
"0","from scipy.stats import poisson"
"0","from scipy.stats import lognorm"
"0","from scipy import signal"
"0","import plotly.graph_objs as go"
"0","import plotly.offline as pyo"
"0","import unittest"
"0","import functions as fn"
"0",""
"0","logging.basicConfig(filename='logs.txt', encoding='utf-8', level=logging.DEBUG)"
"0",""
"0","# """""""
"0","# Function to calculate the convolution of two arrays."
"0","# "
"0","# Args:"
"0","#     a (numpy.ndarray): The first array to be convolved."
"0","#     b (numpy.ndarray): The second array to be convolved."
"0","# "
"0","# Returns:"
"0","#     numpy.ndarray: The convolution of the two input arrays."
"0","# """""""
"0","def convolve(a, b):"
"0","    "
"0","    # Initialize an empty array to store the result."
"0","    c = np.array([])"
"0","    "
"0","    # Compute the convolution of the two arrays."
"0","    for i in range(len(a)):"
"0","        # Get subsets of array expanded to the right."
"0","        a_sub = a[0:i + 1].copy()"
"0","        b_sub = b[0:i + 1].copy()"
"0","        # Reverse b."
"0","        b_rev = b_sub[::-1]"
"0","        # Compute the dot product of a and b_rev."
"0","        c = np.append(c, np.dot(a_sub, b_rev))"
"0","    "
"0","    for i in range(1,len(a)):"
"0","        # Get subsets of array collapse from the right."
"0","        a_sub = a[i:].copy()"
"0","        b_sub = b[i:].copy()"
"0","        # Reverse b."
"0","        b_rev = b_sub[::-1]"
"0","        # Compute the dot product of a and b_rev."
"0","        c = np.append(c, np.dot(a_sub, b_rev))"
"0","        "
"0","    return c"
"0","    "
"0","    "
"0","# """""""
"0","# Function to convolve a distribution with itself n times."
"0","# "
"0","# Args:"
"0","#     a (numpy.ndarray): The distribution to be convolved."
"0","#     n (int): The number of times to convolve the distribution with itself."
"0","# "
"0","# Returns:"
"0","#     numpy.ndarray: The convolution of the input distribution with itself n times."
"0","# """""""
"0","def convolve_n(a, n):"
"0","        "
"0","    # Initialize an empty array to store the result."
"0","    c = np.array([])"
"0","    "
"0","    # If n is 0, return an array of zeros with length equal to the length of a, except for the first element which is 1."
"0","    if n == 0:"
"0","        c = np.array(np.zeros(len(a)), dtype=np.float64)"
"0","        c[0] = 1"
"0","        return c"
"0","    "
"0","    # Convolve the distribution with itself n times."
"0","    for i in range(n):"
"0","        # If this is the first iteration, set c equal to a."
"0","        if i == 0:"
"0","            c = a"
"0","        # Otherwise, convolve c with a."
"0","        else:"
"0","            c = np.convolve(c, a)"
"0","            "
"0","    return c"
"0","# "
"0","# """""""
"0","# Function to create an array of zero arrays according to a given shape array."
"0","# "
"0","# Args:"
"0","#      num_zeros (numpy.ndarray): The shape array."
"0","#      l (int): The length of the zeros array."
"0","#  "
"0","# Returns:"
"0","#      numpy.ndarray: The convolution of the input distribution with itself n times."
"0","# """""""
"0",""
"0","def zero_arrays(num_zeros, l):"
"0","    result = []"
"0","    for n in num_zeros:"
"0","        zeros = np.zeros(l)"
"0","        result.append([zeros] * n)"
"0","    return result"
"0","    "
"0","print(f'Zero arrays are: {zero_arrays(np.array([1, 0, 3]), 4)}')"
"1","Zero arrays are: [[array([0., 0., 0., 0.])], [], [array([0., 0., 0., 0.]), array([0., 0., 0., 0.]), array([0., 0., 0., 0.])]]
"
"0","def calc_distr_limit(l):"
"0","    return int(max(l+4*l**0.5, 100))"
"0","  "
"0","def weak_compositions(n, k):"
"0","    if k == 1:"
"0","        return [[n]]"
"0","    compositions = []"
"0","    for i in range(n + 1):"
"0","        for composition in weak_compositions(n - i, k - 1):"
"0","            compositions.append([i] + composition)"
"0","    return compositions"
"0","  "
"0","print(f'Weak compositions are: {weak_compositions(2, 4)}')"
"1","Weak compositions are: [[0, 0, 0, 2], [0, 0, 1, 1], [0, 0, 2, 0], [0, 1, 0, 1], [0, 1, 1, 0], [0, 2, 0, 0], [1, 0, 0, 1], [1, 0, 1, 0], [1, 1, 0, 0], [2, 0, 0, 0]]
"
"0","class TestConvolve(unittest.TestCase):"
"0","    "
"0","    def test_convolve(self):"
"0","        a = np.array(["
"0","            0.4456796414,"
"0","            0.160623141,"
"0","            0.137676978,"
"0","            0.1032577335])"
"0","        "
"0","        b = np.array(["
"0","            0.006737946999,"
"0","            0.033689735,"
"0","            0.08422433749,"
"0","            0.1403738958])"
"0","        "
"0","        expected_output = np.convolve(a, b)"
"0","        "
"0","        self.assertTrue(np.allclose(convolve(a, b), expected_output))"
"0","        "
"0","if __name__ == '__main__':"
"0","    unittest.main(argv=['first-arg-is-ignored'], exit=False)"
"0",""
"2","."
"2","
----------------------------------------------------------------------
Ran 1 test in 0.001s

OK
"
"1","<unittest.main.TestProgram object at 0x14f596190>
"
