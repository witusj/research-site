"0","import logging"
"0","import copy"
"0","import datetime"
"0","import numpy as np"
"0","from scipy.stats import poisson"
"0","from scipy.stats import lognorm"
"0","from scipy import signal"
"0","import plotly.graph_objs as go"
"0","import plotly.offline as pyo"
"0","import unittest"
"0","import functions as fn"
"0","from itertools import chain, combinations"
"0","import copy"
"0",""
"0","logging.basicConfig(filename='logs.txt', encoding='utf-8', level=logging.DEBUG)"
"0",""
"0","# """""""
"0","# Function to calculate the convolution of two arrays."
"0","# "
"0","# Args:"
"0","#     a (numpy.ndarray): The first array to be convolved."
"0","#     b (numpy.ndarray): The second array to be convolved."
"0","# "
"0","# Returns:"
"0","#     numpy.ndarray: The convolution of the two input arrays."
"0","# """""""
"0","def convolve(a, b):"
"0","    "
"0","    # Initialize an empty array to store the result."
"0","    c = np.array([])"
"0","    "
"0","    # Compute the convolution of the two arrays."
"0","    for i in range(len(a)):"
"0","        # Get subsets of array expanded to the right."
"0","        a_sub = a[0:i + 1].copy()"
"0","        b_sub = b[0:i + 1].copy()"
"0","        # Reverse b."
"0","        b_rev = b_sub[::-1]"
"0","        # Compute the dot product of a and b_rev."
"0","        c = np.append(c, np.dot(a_sub, b_rev))"
"0","    "
"0","    for i in range(1,len(a)):"
"0","        # Get subsets of array collapse from the right."
"0","        a_sub = a[i:].copy()"
"0","        b_sub = b[i:].copy()"
"0","        # Reverse b."
"0","        b_rev = b_sub[::-1]"
"0","        # Compute the dot product of a and b_rev."
"0","        c = np.append(c, np.dot(a_sub, b_rev))"
"0","        "
"0","    return c"
"0","    "
"0","    "
"0","# """""""
"0","# Function to convolve a distribution with itself n times."
"0","# "
"0","# Args:"
"0","#     a (numpy.ndarray): The distribution to be convolved."
"0","#     n (int): The number of times to convolve the distribution with itself."
"0","# "
"0","# Returns:"
"0","#     numpy.ndarray: The convolution of the input distribution with itself n times."
"0","# """""""
"0","def convolve_n(a, n):"
"0","        "
"0","    # Initialize an empty array to store the result."
"0","    c = np.array([])"
"0","    "
"0","    # If n is 0, return an array of zeros with length equal to the length of a, except for the first element which is 1."
"0","    if n == 0:"
"0","        c = np.array(np.zeros(len(a)), dtype=np.float64)"
"0","        c[0] = 1"
"0","        return c"
"0","    "
"0","    # Convolve the distribution with itself n times."
"0","    for i in range(n):"
"0","        # If this is the first iteration, set c equal to a."
"0","        if i == 0:"
"0","            c = a"
"0","        # Otherwise, convolve c with a."
"0","        else:"
"0","            c = np.convolve(c, a)"
"0","            "
"0","    return c"
"0","# "
"0","# """""""
"0","# Function to create an array of zero arrays according to a given shape array."
"0","# "
"0","# Args:"
"0","#      num_zeros (numpy.ndarray): The shape array."
"0","#      l (int): The length of the zeros array."
"0","#  "
"0","# Returns:"
"0","#      numpy.ndarray: The convolution of the input distribution with itself n times."
"0","# """""""
"0",""
"0","def zero_arrays(num_zeros, l):"
"0","    result = []"
"0","    for n in num_zeros:"
"0","        zeros = np.zeros(l)"
"0","        result.append([zeros] * n)"
"0","    return result"
"0","    "
"0","print(f'Zero arrays are: {zero_arrays(np.array([1, 0, 3]), 4)}')"
"1","Zero arrays are: [[array([0., 0., 0., 0.])], [], [array([0., 0., 0., 0.]), array([0., 0., 0., 0.]), array([0., 0., 0., 0.])]]
"
"0","def calc_distr_limit(l):"
"0","    return int(max(l+4*l**0.5, 100))"
"0","  "
"0","def weak_compositions(n, k):"
"0","    if k == 1:"
"0","        return [[n]]"
"0","    compositions = []"
"0","    for i in range(n + 1):"
"0","        for composition in weak_compositions(n - i, k - 1):"
"0","            compositions.append([i] + composition)"
"0","    return compositions"
"0","  "
"0","print(f'Weak compositions are: {weak_compositions(2, 4)}')"
"1","Weak compositions are: [[0, 0, 0, 2], [0, 0, 1, 1], [0, 0, 2, 0], [0, 1, 0, 1], [0, 1, 1, 0], [0, 2, 0, 0], [1, 0, 0, 1], [1, 0, 1, 0], [1, 1, 0, 0], [2, 0, 0, 0]]
"
"0","class TestConvolve(unittest.TestCase):"
"0","    "
"0","    def test_convolve(self):"
"0","        a = np.array(["
"0","            0.4456796414,"
"0","            0.160623141,"
"0","            0.137676978,"
"0","            0.1032577335])"
"0","        "
"0","        b = np.array(["
"0","            0.006737946999,"
"0","            0.033689735,"
"0","            0.08422433749,"
"0","            0.1403738958])"
"0","        "
"0","        expected_output = np.convolve(a, b)"
"0","        "
"0","        self.assertTrue(np.allclose(convolve(a, b), expected_output))"
"0","    "
"0","def powerset(iterable):"
"0","    ""powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)"""
"0","    s = list(iterable)"
"0","    return [list(item) for item in chain.from_iterable(combinations(s, r) for r in range(len(s)+1))]"
"0","  "
"0","def get_v_star(t):"
"0","    # Create an initial vector 'u' of zeros with length 't'"
"0","    u = np.zeros(t, dtype=np.int64)"
"0","    # Set the first element of vector 'u' to -1"
"0","    u[0] = -1"
"0","    # Set the last element of vector 'u' to 1"
"0","    u[-1] = 1"
"0","    # Initialize the list 'v_star' with the initial vector 'u'"
"0","    v_star = [u]"
"0","    # Loop over the length of 'u' minus one times"
"0","    for i in range(len(u) - 1):"
"0","        # Append the last element of 'u' to the front of 'u'"
"0","        u = np.append(u[-1], u)"
"0","        # Remove the last element of 'u' to maintain the same length"
"0","        u = np.delete(u, -1)"
"0","        # Append the updated vector 'u' to the list 'v_star'"
"0","        v_star.append(u)"
"0","    # Convert the list of vectors 'v_star' into a NumPy array and return it"
"0","    return(np.array(v_star))"
"0","    "
"0","# Example of function call:"
"0","# This will create a 4x4 matrix where each row is a cyclically shifted version of the first row"
"0",""
"0","def generate_search_neighborhood(schedule):"
"0","  N = sum(schedule)"
"0","  T = len(schedule)"
"0","  logging.info(f'The schedule = {schedule}')"
"0","  "
"0","  # Generate a matrix 'v_star' using the 'get_v_star' function"
"0","  v_star = get_v_star(T)"
"0","  "
"0","  # Generate all possible non-empty subsets (powerset) of the set {0, 1, 2, ..., T-1}"
"0","  # 'ids' will be a list of tuples, where each tuple is a subset of indices"
"0","  ids = list(powerset(range(T)))"
"0","  "
"0","  # Select the vectors from 'v_star' that correspond to the indices in each subset"
"0","  # 'sub_sets' will be a list of lists, where each inner list contains vectors from 'v_star'"
"0","  sub_sets = [v_star[i] for i in ids]"
"0","  "
"0","  # Sum the vectors within each subset and flatten the result to get a 1-D array"
"0","  # 'summed_sets' will be a list of 1-D numpy arrays, where each array is the sum of vectors"
"0","  summed_sets = [np.sum(sub_sets[i], axis=0).flatten() for i in range(len(sub_sets))]"
"0","  "
"0","  neighborhood = np.array([schedule + summed_sets[i] for i in range(len(summed_sets))])"
"0","  "
"0","  # Create a mask for rows with negative values"
"0","  mask = ~np.any(neighborhood < 0, axis=1)"
"0","  "
"0","  # Filter out rows with negative values using the mask"
"0","  filtered_neighborhood = neighborhood[mask]"
"0","  logging.info(f'And the neighborhood is {filtered_neighborhood}')"
"0","  return filtered_neighborhood"
"0","  "
"0","def generate_small_search_neighborhood(schedule):"
"0","  N = sum(schedule)"
"0","  T = len(schedule)"
"0","  logging.info(f'The schedule = {schedule}')"
"0","  "
"0","  # Generate a matrix 'v_star' using the 'get_v_star' function"
"0","  v_star = get_v_star(T)"
"0","  "
"0","  neighborhood = np.array([schedule + v_star[i] for i in range(len(v_star))])"
"0","  "
"0","  # Create a mask for rows with negative values"
"0","  mask = ~np.any(neighborhood < 0, axis=1)"
"0","  "
"0","  # Filter out rows with negative values using the mask"
"0","  filtered_neighborhood = neighborhood[mask]"
"0","  logging.info(f'And the neighborhood is {filtered_neighborhood}')"
"0","  return filtered_neighborhood"
"0","  "
"0","def distribute_patients(n_patients, n_timeslots):"
"0","    # Create a list with all slots initially empty"
"0","    distribution = [0] * n_timeslots"
"0","    "
"0","    # Place patients in timeslots"
"0","    for i in range(n_patients):"
"0","        # Calculate the slot for each patient"
"0","        slot = round(i * n_timeslots / n_patients)"
"0","        distribution[slot] = 1"
"0","        "
"0","    return distribution"
"0","    "
"0","def plot_timeline(slots):"
"0","    # Create a figure"
"0","    fig = go.Figure()"
"0","    "
"0","    # Iterate over each timeslot and add a bar for occupied slots"
"0","    for i, slot in enumerate(slots):"
"0","        fig.add_trace(go.Bar(x=[i], y=[slot], width=0.8, marker_color='black'))"
"0","        "
"0","    # Update layout"
"0","    fig.update_layout("
"0","        title=""Timeline of Occupied Timeslots"","
"0","        xaxis_title=""Timeslots"","
"0","        yaxis=dict(showticklabels=False, showgrid=False, zeroline=False),"
"0","        showlegend=False"
"0","    )"
"0","    "
"0","    # Set y-axis range"
"0","    fig.update_yaxes(range=[0, np.max(slots)])"
"0","    "
"0","    # Show the figure"
"0","    fig.show()"
"0",""
