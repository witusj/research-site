"0",""
"0",""""""""
"0","A schedule class with a constructor and a method to calculate the system states."
"0",""""""""
"1","'\nA schedule class with a constructor and a method to calculate the system states.\n'
"
"0","class Schedule:"
"0","    def __init__(self, x, d, s):"
"0","        """""""
"0","        Initialize the Schedule class with patient schedules and a service time distribution."
"0","        "
"0","        Args:"
"0","            x (list): A list of integers representing the number of patients scheduled to arrive at each time step."
"0","            d (int): An integer representing the length of a time interval."
"0","            s (list): A list of floats representing the probability distribution of service times."
"0","        """""""
"0","        if not all(isinstance(i, np.integer) and i >= 0 for i in x):"
"0","            raise ValueError(""All elements in x must be non-negative integers."")"
"0","        if not isinstance(d, int) or d <= 0:"
"0","            raise ValueError(""d must be a positive integer."")"
"0","        if not all(isinstance(i, float) and 0 <= i <= 1 for i in s):"
"0","            raise ValueError(""All elements in s must be floats between 0 and 1."")"
"0","            "
"0","        self.parameters = {'x': x, 'd': d, 's': s}"
"0","        self._initialize_system()"
"0","            "
"0","    def _initialize_system(self):"
"0","        """""" Initialize the system's internal state. """""""
"0","        self.state = 0"
"0","        length_x = len(self.parameters['x'])"
"0","        length_s = len(self.parameters['s'])"
"0","        self.system = {"
"0","            'p_min': np.zeros((length_x + 1, length_s), dtype=np.float64),"
"0","            'p_plus': np.zeros((length_x, length_s), dtype=np.float64),"
"0","            'w': [np.zeros((i, length_s), dtype=np.float64) for i in self.parameters['x']],"
"0","            'ew': np.zeros(length_x, dtype=np.float64)"
"0","        }"
"0","        self.system['p_min'][0][0] = 1"
"0","        if(self.parameters['x'][0] > 0): # Only calculate waiting times if there are patients scheduled in the state"
"0","                     self.system['w'][0][0] = self.system['p_min'][0].copy()"
"0","                     for i in range(1, self.parameters['x'][0]):"
"0","                            self.system['w'][0][i] = np.convolve(self.system['w'][0][i-1], self.parameters['s'])[:(len(self.parameters['s']))]"
"0","        self._update_p_plus(0)"
"0","        self.state = 1"
"0","            "
"0","    def _update_p_plus(self, state):"
"0","        """""" Update the p_plus array based on the current state. """""""
"0","        if self.parameters['x'][state] == 0:"
"0","            self.system['p_plus'][state] = self.system['p_min'][state].copy()"
"0","        else:"
"0","            self.system['p_plus'][state] = np.convolve(self.system['w'][state][-1], self.parameters['s'], mode='full')[:len(self.parameters['s'])]"
"0","        logging.info(f""p_plus = {self.system['p_plus'][state]}"")"
"0","            "
"0","    def _calculate_state(self):"
"0","        logging.info(f'{datetime.datetime.now()} - State = {self.state}')"
"0","        "
"0","        """"""The probability that the amount of work left in the system equals zero just before state t starts is the probablity that the total amount work in state t-1 was less than or equal to the interval length d."""""""
"0","        logging.info(f'{datetime.datetime.now()} - Calculating p_min in state {self.state}')"
"0","        self.system['p_min'][self.state][0] = np.sum(self.system['p_plus'][self.state-1][:(self.parameters['d'] + 1)])"
"0","        "
"0","        """"""The probability that the amount of work left in the system equals i just before state t starts is the probablity that the total amount work in state t-1 exceeded the interval length d with amount i."""""""
"0","        "
"0","        self.system['p_min'][self.state][1:(-1*self.parameters['d'])] = self.system['p_plus'][self.state-1][(self.parameters['d'] + 1):]"
"0","        "
"0","        """"""The distribution of waiting times of the first patient in state t equals p_min. "
"0","        The distribution of waiting times of the second patient in state t equals the convolution of the distribution "
"0","        of waiting times of the first patient in state t and the service time distribution. "
"0","        The resulting vector is truncated to the length of the service time distribution."""""""
"0","        if(self.parameters['x'][self.state] > 0): # Only calculate waiting times if there are patients scheduled in the state"
"0","                logging.info(f'{datetime.datetime.now()} - Calculating w[{self.state}][0] in state {self.state}')"
"0","                self.system['w'][self.state][0] = self.system['p_min'][self.state].copy()"
"0","                logging.info(self.system['w'][self.state][0])"
"0","                logging.info(f'{datetime.datetime.now()} - Done')"
"0","                for i in range(1, self.parameters['x'][self.state]):"
"0","                    logging.info(f'{datetime.datetime.now()} - Calculating w[{self.state}][{i}] in state {self.state}')"
"0","                    self.system['w'][self.state][i] = np.convolve(self.system['w'][self.state][i-1], self.parameters['s'])[:(len(self.parameters['s']))]"
"0","                    logging.info(self.system['w'][self.state][i])"
"0","                    "
"0","        """"""The probablitity that the amount of work left in the system equals i just before state t ends equals "
"0","        the convolution of the waiting time distribution of the last arriving patient and the service time distribution. "
"0","        Unless there are no patients in the state t. In that case the distribution of total work just before t ends is equal "
"0","        to the distribution of work at the beginning of t. "
"0","        The resulting vector is truncated to the length of the service time distribution."""""""
"0","        logging.info(f'{datetime.datetime.now()} - Calculating p_plus in state {self.state}')"
"0","        self._update_p_plus(self.state)"
"0","    "
"0","    def calculate_system_states(self, until=1):"
"0","        """""""
"0","        Calculate the probabilities of the system being in each state at each time step."
"0","        "
"0","        Args:"
"0","            until (int, optional): The state until which to calculate the probabilities. Defaults to 1."
"0","        """""""
"0","        while self.state < until:"
"0","            self._calculate_state()"
"0","            self.state += 1"
"0","  "
"0","      "
"0","    def local_search(self, omega=0.5):"
"0","        """""""
"0","        Generate for a given schedule a local search environment, establish for each schedule in the environment the lowest total waiting time, if a schedule with a lower waiting time is found, use this schedule to generate a new local environment and search this environment for lower waiting times. When a local environment contains no schedules with lower waiting stop searching.  "
"0","        """""""
"0","        "
"0","        # Calculate initial loss"
"0","        test_wt = self.system[""ew""].sum()"
"0","        self.calculate_tardiness()"
"0","        indices = np.arange(self.system['p_min'][-1].size) "
"0","        exp_tard = (indices * self.system['p_min'][-1]).sum()"
"0","        lowest_loss = omega * test_wt / self.parameters['x'].sum() + (1 - omega) * exp_tard"
"0","        store_optim = dict({ 'x' : self.parameters['x'].copy(), 'system' : copy.deepcopy(self.system), 'tot_wt' : test_wt})"
"0","        "
"0","        # Continue the search until no improvement is found"
"0","        while True:  # Start an outer loop that will continue until explicitly broken"
"0","            nh = generate_search_neighborhood(self.parameters['x'])  # Generate a new neighborhood"
"0","            improved = False  # Flag to check if an improvement was found in the inner loop"
"0","            "
"0","            for y in nh:  # Inner loop to search through the neighborhood"
"0","                # Insert first element of nh in x"
"0","                self.parameters['x'] = y.copy()"
"0","                logging.info(f""Test schedule = {self.parameters['x']}"")"
"0","                # Set starting state"
"0","                self.state = 0"
"0","                # If start state is 0 reinitialize p_min, w and p_plus in state 0"
"0","                self._initialize_system()"
"0","                self.calculate_system_states(until=len(self.parameters['x']))"
"0","                logging.info(""System recalculated"")"
"0","                self.calculate_wait_times()"
"0","                test_wt = self.system[""ew""].sum()"
"0","                logging.info(f""Average waiting time={test_wt / self.parameters['x'].sum()}"")"
"0","                self.calculate_tardiness()"
"0","                indices = np.arange(self.system['p_min'][-1].size) "
"0","                exp_tard = (indices * self.system['p_min'][-1]).sum()"
"0","                logging.info(f'Expected tardiness={exp_tard}')"
"0","                test_loss = omega * test_wt / self.parameters['x'].sum() + (1 - omega) * exp_tard"
"0","                logging.info(f'obj_value = {test_loss}')"
"0","                # If a composition with a lower waiting time is found, store the system"
"0","                if(test_loss < lowest_loss):"
"0","                    lowest_loss = test_loss"
"0","                    store_optim['x'] = self.parameters['x'].copy()"
"0","                    newsystem = copy.deepcopy(self.system)"
"0","                    store_optim['system'] = newsystem"
"0","                    store_optim['tot_wt'] = test_wt"
"0","                    logging.info(f'{datetime.datetime.now()} - Found lower loss = {lowest_loss} with x = {store_optim[""x""]} and system = {store_optim[""system""]}')"
"0","                    improved = True  # Set the flag because an improvement was found"
"0","                    break  # Exit the inner loop to generate a new neighborhood"
"0","            "
"0","            if not improved:  # If no improvement was found in the inner loop"
"0","                logging.info(f'Finished searching')"
"0","                # Set the system to the stored optimal system "
"0","                logging.info(f'{datetime.datetime.now()} - Final result lowest loss = {lowest_loss} with x = {store_optim[""x""]} and system = {store_optim[""system""]}')"
"0","                self.parameters['x'] = store_optim['x'].copy()"
"0","                self.system['p_min'] = store_optim['system']['p_min']"
"0","                self.system['p_plus'] = store_optim['system']['p_plus']"
"0","                self.system['w'] = store_optim['system']['w']"
"0","                self.system['ew'] = store_optim['system']['ew']"
"0","                break  # Exit the outer loop - the search is complete"
"0","      "
"0","    def small_local_search(self, omega=0.5):"
"0","        """""""
"0","        Generate for a given schedule a local search environment, establish for each schedule in the environment the lowest total waiting time, if a schedule with a lower waiting time is found, use this schedule to generate a new local environment and search this environment for lower waiting times. When a local environment contains no schedules with lower waiting stop searching.  "
"0","        """""""
"0","        "
"0","        # Calculate initial loss"
"0","        test_wt = self.system[""ew""].sum()"
"0","        self.calculate_tardiness()"
"0","        indices = np.arange(self.system['p_min'][-1].size) "
"0","        exp_tard = (indices * self.system['p_min'][-1]).sum()"
"0","        lowest_loss = omega * test_wt / self.parameters['x'].sum() + (1 - omega) * exp_tard"
"0","        store_optim = dict({ 'x' : self.parameters['x'].copy(), 'system' : copy.deepcopy(self.system), 'tot_wt' : test_wt})"
"0","        "
"0","        # Continue the search until no improvement is found"
"0","        while True:  # Start an outer loop that will continue until explicitly broken"
"0","            nh = generate_search_neighborhood(self.parameters['x'])  # Generate a new neighborhood"
"0","            improved = False  # Flag to check if an improvement was found in the inner loop"
"0","            "
"0","            for y in nh:  # Inner loop to search through the neighborhood"
"0","                # Insert first element of nh in x"
"0","                self.parameters['x'] = y.copy()"
"0","                logging.info(f""Test schedule = {self.parameters['x']}"")"
"0","                # Set starting state"
"0","                self.state = 0"
"0","                # If start state is 0 reinitialize p_min, w and p_plus in state 0"
"0","                self._initialize_system()"
"0","                self.calculate_system_states(until=len(self.parameters['x']))"
"0","                logging.info(""System recalculated"")"
"0","                self.calculate_wait_times()"
"0","                test_wt = self.system[""ew""].sum()"
"0","                logging.info(f""Average waiting time={test_wt / self.parameters['x'].sum()}"")"
"0","                self.calculate_tardiness()"
"0","                indices = np.arange(self.system['p_min'][-1].size) "
"0","                exp_tard = (indices * self.system['p_min'][-1]).sum()"
"0","                logging.info(f'Expected tardiness={exp_tard}')"
"0","                test_loss = omega * test_wt / self.parameters['x'].sum() + (1 - omega) * exp_tard"
"0","                logging.info(f'obj_value = {test_loss}')"
"0","                # If a composition with a lower waiting time is found, store the system"
"0","                if(test_loss < lowest_loss):"
"0","                    lowest_loss = test_loss"
"0","                    store_optim['x'] = self.parameters['x'].copy()"
"0","                    newsystem = copy.deepcopy(self.system)"
"0","                    store_optim['system'] = newsystem"
"0","                    store_optim['tot_wt'] = test_wt"
"0","                    logging.info(f'{datetime.datetime.now()} - Found lower loss = {lowest_loss} with x = {store_optim[""x""]} and system = {store_optim[""system""]}')"
"0","                    improved = True  # Set the flag because an improvement was found"
"0","                    break  # Exit the inner loop to generate a new neighborhood"
"0","            "
"0","            if not improved:  # If no improvement was found in the inner loop"
"0","                logging.info(f'Finished searching')"
"0","                # Set the system to the stored optimal system "
"0","                logging.info(f'{datetime.datetime.now()} - Final result lowest loss = {lowest_loss} with x = {store_optim[""x""]} and system = {store_optim[""system""]}')"
"0","                self.parameters['x'] = store_optim['x'].copy()"
"0","                self.system['p_min'] = store_optim['system']['p_min']"
"0","                self.system['p_plus'] = store_optim['system']['p_plus']"
"0","                self.system['w'] = store_optim['system']['w']"
"0","                self.system['ew'] = store_optim['system']['ew']"
"0","                break  # Exit the outer loop - the search is complete"
"0","                "
"0","    def calculate_tardiness(self):"
"0","        """""""
"0","        Calculate the tardiness for the current system and add it as the last element to p_min - the distribution of work in interval t just before any patient has arrived. "
"0","        """""""
"0","        self.system['p_min'][-1][0] = np.sum(self.system['p_plus'][-1][:(self.parameters['d'] + 1)])"
"0","        self.system['p_min'][-1][1:(-1*self.parameters['d'])] = self.system['p_plus'][-1][(self.parameters['d'] + 1):]"
"0","        logging.info(f'{datetime.datetime.now()} - calculating tardiness distribution:  {self.system[""p_min""][-1]}')"
"0","        "
"0","    def calculate_wait_times(self):"
"0","        """""""
"0","        Calculate the expected waiting time for each time step."
"0","        """""""
"0","        for interval, wtdists in enumerate(self.system['w']):"
"0","            ew = 0"
"0","            for nr, dist in enumerate(wtdists):"
"0","                # Calculate the weighted sum of the waiting time distribution"
"0","                a = range(len(dist))"
"0","                b = dist"
"0","                meanwt = np.dot(a, b)"
"0","                logging.info(f""Mean waiting time for patient {nr} in interval {interval} = {meanwt}"")"
"0","                ew += meanwt"
"0","            # Store the expected waiting time for the current time step"
"0","            self.system['ew'][interval] = ew"
"0","        "
"0","        "
"0","    def visualize_state(self, state='', dist='p_plus'):"
"0","        """""""
"0","        Visualize a distribution in the last given state."
"0","        "
"0","        Args:"
"0","        state (int): An optional integer representing the state to visualize. If not provided, the current state is used."
"0","        dist (str): An optional string representing the distribution to visualize. Defaults to 'p_plus'."
"0","        """""""
"0","        if state == '':"
"0","            state = self.state"
"0","        trace = go.Scatter("
"0","            x=list(range(len(self.system[dist][state]))),"
"0","            y=self.system[dist][state],"
"0","            mode='lines'"
"0","        )"
"0","        "
"0","        data = [trace]"
"0","        "
"0","        layout = go.Layout("
"0","            title=f'{dist} in state {state} with x = {self.parameters[""x""]}<br><sub>AUR = {np.round(np.sum(self.system[dist][state]), 3)}</sub>',"
"0","            xaxis=dict(title='Time'),"
"0","            yaxis=dict(title='Probability')"
"0","        )"
"0","        "
"0","        fig = go.Figure(data=data, layout=layout)"
"0","        pyo.iplot(fig)"
"0","    "
"0","    def visualize_system(self, dist='p_plus'):"
"0","        l = len(self.parameters[""x""])"
"0","        suffix = """""
"0","        if(dist=='p_min'): suffix = f'<br>NB: p_min[{l}] contains tardiness distribution'"
"0","        """""""
"0","        Visualize a distribution for the entire system."
"0","        "
"0","        Args:"
"0","        dist (str): An optional string representing the distribution to visualize. Defaults to 'p_plus'."
"0","        """""""
"0","        values = self.system[dist]"
"0","        trace = go.Heatmap("
"0","                    z=values"
"0","                    )"
"0","        data = [trace]"
"0","        layout = go.Layout("
"0","            title=f'{dist} with x = {self.parameters[""x""]}{suffix}',"
"0","            xaxis=dict(title='Time'),"
"0","            yaxis=dict(title='Interval')"
"0","        )"
"0","        fig = go.Figure(data=data, layout=layout)"
"0","        pyo.iplot(fig)"
"0","        "
"0","    def __str__(self):"
"0","        """""""
"0","        Print all probabilities"
"0","        """""""
"0","        return(""p_min = % s \nw = % s \np_plus = % s \new = % s"" % (self.system['p_min'], self.system['w'], self.system['p_plus'], self.system['ew']))"
"0",""
