"0",""
"0","# """""""
"0","# Function to calculate the convolution of two arrays."
"0","# "
"0","# Args:"
"0","#     a (numpy.ndarray): The first array to be convolved."
"0","#     b (numpy.ndarray): The second array to be convolved."
"0","# "
"0","# Returns:"
"0","#     numpy.ndarray: The convolution of the two input arrays."
"0","# """""""
"0","def convolve(a, b):"
"0","    "
"0","    # Initialize an empty array to store the result."
"0","    c = np.array([])"
"0","    "
"0","    # Compute the convolution of the two arrays."
"0","    for i in range(len(a)):"
"0","        # Get subsets of array expanded to the right."
"0","        a_sub = a[0:i + 1].copy()"
"0","        b_sub = b[0:i + 1].copy()"
"0","        # Reverse b."
"0","        b_rev = b_sub[::-1]"
"0","        # Compute the dot product of a and b_rev."
"0","        c = np.append(c, np.dot(a_sub, b_rev))"
"0","    "
"0","    for i in range(1,len(a)):"
"0","        # Get subsets of array collapse from the right."
"0","        a_sub = a[i:].copy()"
"0","        b_sub = b[i:].copy()"
"0","        # Reverse b."
"0","        b_rev = b_sub[::-1]"
"0","        # Compute the dot product of a and b_rev."
"0","        c = np.append(c, np.dot(a_sub, b_rev))"
"0","        "
"0","    return c"
"0","    "
"0","    "
"0","# """""""
"0","# Function to convolve a distribution with itself n times."
"0","# "
"0","# Args:"
"0","#     a (numpy.ndarray): The distribution to be convolved."
"0","#     n (int): The number of times to convolve the distribution with itself."
"0","# "
"0","# Returns:"
"0","#     numpy.ndarray: The convolution of the input distribution with itself n times."
"0","# """""""
"0","def convolve_n(a, n):"
"0","        "
"0","    # Initialize an empty array to store the result."
"0","    c = np.array([])"
"0","    "
"0","    # If n is 0, return an array of zeros with length equal to the length of a, except for the first element which is 1."
"0","    if n == 0:"
"0","        c = np.array(np.zeros(len(a)), dtype=np.float64)"
"0","        c[0] = 1"
"0","        return c"
"0","    "
"0","    # Convolve the distribution with itself n times."
"0","    for i in range(n):"
"0","        # If this is the first iteration, set c equal to a."
"0","        if i == 0:"
"0","            c = a"
"0","        # Otherwise, convolve c with a."
"0","        else:"
"0","            c = np.convolve(c, a)"
"0","            "
"0","    return c"
"0","# "
"0","# """""""
"0","# Function to create an array of zero arrays according to a given shape array."
"0","# "
"0","# Args:"
"0","#      num_zeros (numpy.ndarray): The shape array."
"0","#      l (int): The length of the zeros array."
"0","#  "
"0","# Returns:"
"0","#      numpy.ndarray: The convolution of the input distribution with itself n times."
"0","# """""""
"0",""
"0","def zero_arrays(num_zeros, l):"
"0","    result = []"
"0","    for n in num_zeros:"
"0","        zeros = np.zeros(l)"
"0","        result.append([zeros] * n)"
"0","    return result"
"0","    "
"0","print(f'Zero arrays are: {zero_arrays(np.array([1, 0, 3]), 4)}')"
"1","Zero arrays are: [[array([0., 0., 0., 0.])], [], [array([0., 0., 0., 0.]), array([0., 0., 0., 0.]), array([0., 0., 0., 0.])]]
"
"0","def calc_distr_limit(l):"
"0","    return int(max(l+4*l**0.5, 100))"
"0","  "
"0","class TestConvolve(unittest.TestCase):"
"0","    "
"0","    def test_convolve(self):"
"0","        a = np.array(["
"0","            0.4456796414,"
"0","            0.160623141,"
"0","            0.137676978,"
"0","            0.1032577335])"
"0","        "
"0","        b = np.array(["
"0","            0.006737946999,"
"0","            0.033689735,"
"0","            0.08422433749,"
"0","            0.1403738958])"
"0","        "
"0","        expected_output = np.convolve(a, b)"
"0","        "
"0","        self.assertTrue(np.allclose(convolve(a, b), expected_output))"
"0","    "
"0","def powerset(iterable):"
"0","    ""powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)"""
"0","    s = list(iterable)"
"0","    return [list(item) for item in chain.from_iterable(combinations(s, r) for r in range(len(s)+1))]"
"0","    "
"0","def get_v_star(t):"
"0","    # Create an initial vector 'u' of zeros with length 't'"
"0","    u = np.zeros(t, dtype=np.int64)"
"0","    # Set the first element of vector 'u' to -1"
"0","    u[0] = -1"
"0","    # Set the last element of vector 'u' to 1"
"0","    u[-1] = 1"
"0","    # Initialize the list 'v_star' with the initial vector 'u'"
"0","    v_star = [u]"
"0","    # Loop over the length of 'u' minus one times"
"0","    for i in range(len(u) - 1):"
"0","        # Append the last element of 'u' to the front of 'u'"
"0","        u = np.append(u[-1], u)"
"0","        # Remove the last element of 'u' to maintain the same length"
"0","        u = np.delete(u, -1)"
"0","        # Append the updated vector 'u' to the list 'v_star'"
"0","        v_star.append(u)"
"0","    # Convert the list of vectors 'v_star' into a NumPy array and return it"
"0","    logging.info(f'V_star = {v_star}')"
"0","    return(np.array(v_star))"
"0","    "
"0","# Example of function call:"
"0","# This will create a 4x4 matrix where each row is a cyclically shifted version of the first row"
"0",""
"0","def generate_search_neighborhood(schedule):"
"0","  N = sum(schedule)"
"0","  T = len(schedule)"
"0","  logging.info(f'The schedule = {schedule}')"
"0","  "
"0","  # Generate a matrix 'v_star' using the 'get_v_star' function"
"0","  v_star = get_v_star(T)"
"0","  "
"0","  # Generate all possible non-empty subsets (powerset) of the set {0, 1, 2, ..., T-1}"
"0","  # 'ids' will be a list of tuples, where each tuple is a subset of indices"
"0","  ids = list(powerset(range(T)))"
"0","  "
"0","  logging.info(f'Neighborhood size = {len(ids)}')"
"0","  "
"0","  # Select the vectors from 'v_star' that correspond to the indices in each subset"
"0","  # 'sub_sets' will be a list of lists, where each inner list contains vectors from 'v_star'"
"0","  sub_sets = [v_star[i] for i in ids]"
"0","  "
"0","  # Sum the vectors within each subset and flatten the result to get a 1-D array"
"0","  # 'summed_sets' will be a list of 1-D numpy arrays, where each array is the sum of vectors"
"0","  summed_sets = [np.sum(sub_sets[i], axis=0).flatten() for i in range(len(sub_sets))]"
"0","  logging.info(f'Summed sets = {summed_sets}')"
"0","  "
"0","  neighborhood = np.array([schedule + summed_sets[i] for i in range(len(summed_sets))])"
"0","  logging.info(f'Neighborhood = {neighborhood}')"
"0","  "
"0","  # Create a mask for rows with negative values"
"0","  mask = ~np.any(neighborhood < 0, axis=1)"
"0","  "
"0","  # Filter out rows with negative values using the mask"
"0","  filtered_neighborhood = neighborhood[mask]"
"0","  logging.info(f'And the neighborhood is {filtered_neighborhood}')"
"0","  return filtered_neighborhood"
"0","  "
"0","def generate_small_search_neighborhood(schedule):"
"0","  N = sum(schedule)"
"0","  T = len(schedule)"
"0","  logging.info(f'The schedule = {schedule}')"
"0","  "
"0","  # Generate a matrix 'v_star' using the 'get_v_star' function"
"0","  v_star = get_v_star(T)"
"0","  "
"0","  neighborhood = np.array([schedule + v_star[i] for i in range(len(v_star))])"
"0","  "
"0","  # Create a mask for rows with negative values"
"0","  mask = ~np.any(neighborhood < 0, axis=1)"
"0","  "
"0","  # Filter out rows with negative values using the mask"
"0","  filtered_neighborhood = neighborhood[mask]"
"0","  logging.info(f'And the neighborhood is {filtered_neighborhood}')"
"0","  return filtered_neighborhood"
"0","  "
"0","def distribute_patients(n_patients, n_timeslots):"
"0","    # Create a list with all slots initially empty"
"0","    distribution = [0] * n_timeslots"
"0","    "
"0","    # Place patients in timeslots"
"0","    for i in range(n_patients):"
"0","        # Calculate the slot for each patient"
"0","        slot = round(i * n_timeslots / n_patients)"
"0","        distribution[slot] = 1"
"0","        "
"0","    return distribution"
"0","    "
"0","def plot_timeline(slots, title):"
"0","    # Create a figure"
"0","    fig = go.Figure()"
"0","    "
"0","    # Iterate over each timeslot and add a bar for occupied slots"
"0","    for i, slot in enumerate(slots):"
"0","        fig.add_trace(go.Bar(x=[i], y=[slot], width=0.8, marker_color='black'))"
"0","        "
"0","    # Update layout"
"0","    fig.update_layout("
"0","        title=title,"
"0","        xaxis_title=""Timeslots"","
"0","        yaxis=dict(showticklabels=False, showgrid=False, zeroline=False),"
"0","        showlegend=False"
"0","    )"
"0","    "
"0","    # Set y-axis range"
"0","    fig.update_yaxes(range=[0, np.max(slots)])"
"0","    "
"0","    # Show the figure"
"0","    fig.show()"
"0","    "
"0","def service_time_with_no_shows(s, q):"
"0","  # """""""
"0","  # Function to adjust a distribution of service times for no-shows"
"0","  # "
"0","  # Args:"
"0","  #     s (numpy.ndarray): An array with service times."
"0","  #     q (double): The fraction of no-shows."
"0","  # "
"0","  # Returns:"
"0","  #     numpy.ndarray: The adjusted array of service times."
"0","  # """""""
"0","  "
"0","  s_adj = [(1 - q) * float(si) for si in s]"
"0","  s_adj[0] = s_adj[0] + q"
"0","  return(s_adj)"
"0","  "
"0","def add_lists(short_list, long_list):"
"0","  # """""""
"0","  # This function takes in two lists and returns a new list where each element "
"0","  # is the sum of the elements from the input lists at the corresponding position."
"0","  # If the lists are of different lengths, the shorter list is extended with zeros "
"0","  # to match the length of the longer list."
"0","  # "
"0","  # Parameters:"
"0","  # - short_list (list): The shorter list of numbers."
"0","  # - long_list (list): The longer list of numbers."
"0","  # "
"0","  # Returns:"
"0","  # - list: A list containing the element-wise sum of the two input lists."
"0","  # """""""
"0","  "
"0","  # Extend the short lists to the length of the long list with zeros"
"0","  short_list.extend([0] * (len(long_list) - len(short_list)))"
"0","  "
"0","  # Sum the elements of the two lists element-wise"
"0","  result = [a + b for a, b in zip(short_list, long_list)]"
"0","  "
"0","  return result"
"0","  "
"0","def calculate_rolling_convolution(p_y, s):"
"0","  conv_list = s"
"0","  limit = len(p_y)"
"0","  v = [x * p_y[0] for x in conv_list]"
"0","  for i in range(1, limit):"
"0","    conv_list = np.convolve(conv_list, s)"
"0","    v = add_lists(v, [x * p_y[i] for x in conv_list])"
"0","    "
"0","  return(v)"
"0","  "
"0","def generate_schedules(N):"
"0","    """""""
"0","    Generate all possible ways to distribute N patients into 3 timeslots."
"0","    The function returns a list of lists, where each sublist represents"
"0","    a distribution of patients across the 3 timeslots such that the sum of"
"0","    the numbers in the sublist is N."
"0","    "
"0","    Parameters:"
"0","    N (int): The total number of patients to be distributed."
"0","    "
"0","    Returns:"
"0","    List[List[int]]: A list of lists where each sublist contains 3 integers"
"0","    representing a possible distribution of patients across the 3 timeslots."
"0","    """""""
"0","    # This list will hold the result"
"0","    schedules = []"
"0","    "
"0","    # Iterate over all possible values of 'a' from 0 to N (inclusive)"
"0","    for a in range(N + 1):"
"0","        # For each value of 'a', iterate over all possible values of 'b' from 0 to N-a (inclusive)"
"0","        for b in range(N - a + 1):"
"0","            # Compute 'c' such that the sum of 'a', 'b', and 'c' is N"
"0","            c = N - a - b"
"0","            # Append the combination [a, b, c] to the schedules list"
"0","            schedules.append([a, b, c])"
"0","            "
"0","    # Return the list of all possible schedules"
"0","    return schedules"
"0",""
