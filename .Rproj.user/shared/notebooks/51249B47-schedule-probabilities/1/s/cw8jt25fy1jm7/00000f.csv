"0",""
"0",""""""""
"0","A schedule class with a constructor and a method to calculate the system states."
"0",""""""""
"1","'\nA schedule class with a constructor and a method to calculate the system states.\n'
"
"0","class Schedule:"
"0","    def __init__(self, x, d, s):"
"0","            """""""
"0","            Initialize the class with a schedule of patients and a service time distribution."
"0","            "
"0","            Args:"
"0","            d (int): An integer representing the time lenght of an interval."
"0","            x (list): A list of integers representing the number of patients scheduled to arrive at each time step."
"0","            s (list): A list of floats representing the probability distribution of service times."
"0","            """""""
"0","            "
"0","            self.parameters = dict({'x': x, 'd': d, 's': s})"
"0","            logging.info(f'{datetime.datetime.now()} - x = {self.parameters[""x""]}')"
"0","            # Initialize the system dictionary with p_min and p_plus. p_min has one element extra for storing tardiness"
"0","            self.system = dict({"
"0","                'p_min': np.zeros((len(self.parameters['x']) + 1, len(self.parameters['s'])), dtype=np.float64),"
"0","                'p_plus': np.zeros((len(self.parameters['x']), len(self.parameters['s'])), dtype=np.float64)"
"0","            })"
"0","            # Set the first element of p_min in the initial state to 1."
"0","            self.system['p_min'][0][0] = 1"
"0","            # Initialize array of arrays for saving waiting times distributions per patient"
"0","            self.system['w'] = zero_arrays(self.parameters['x'].copy(), len(self.parameters['s']))"
"0","            if(self.parameters['x'][0] > 0): # Only calculate waiting times if there are patients scheduled in the state"
"0","                     self.system['w'][0][0] = self.system['p_min'][0].copy()"
"0","                     for i in range(1, self.parameters['x'][0]):"
"0","                            self.system['w'][0][i] = np.convolve(self.system['w'][0][i-1], self.parameters['s'])[:(len(self.parameters['s']))]"
"0","            self.system['p_plus'][0] = self.system['p_min'][0].copy() if self.parameters['x'][0] == 0 else np.convolve(self.system['w'][0][-1], self.parameters['s'])[:(len(self.parameters['s']))]"
"0","            # Initialize array for saving total expected waiting times per state"
"0","            self.system['ew'] = np.zeros(len(self.parameters['x']), dtype=np.float64)"
"0","            # Set the initial state to 1."
"0","            self.state = 1"
"0","        "
"0","    def calculate_system_states(self, until = 1):"
"0","            """""""
"0","            Calculate the probabilities of the system being in each state at each time step."
"0","            "
"0","            Args:"
"0","            until (int): An optional integer representing the state until which to calculate the probabilities."
"0","            """""""
"0","            "
"0","            while self.state < until:"
"0","                logging.info(f'{datetime.datetime.now()} - State = {self.state}')"
"0","                "
"0","                """"""The probability that the amount of work left in the system equals zero just before state t starts is the probablity that the total amount work in state t-1 was less than or equal to the interval length d."""""""
"0","                logging.info(f'{datetime.datetime.now()} - Calculating p_min in state {self.state}')"
"0","                self.system['p_min'][self.state][0] = np.sum(self.system['p_plus'][self.state-1][:(self.parameters['d'] + 1)])"
"0","                "
"0","                """"""The probability that the amount of work left in the system equals i just before state t starts is the probablity that the total amount work in state t-1 exceeded the interval length d with amount i."""""""
"0","                "
"0","                self.system['p_min'][self.state][1:(-1*self.parameters['d'])] = self.system['p_plus'][self.state-1][(self.parameters['d'] + 1):]"
"0","                "
"0","                """"""The distribution of waiting times of the first patient in state t equals p_min. "
"0","                The distribution of waiting times of the second patient in state t equals the convolution of the distribution "
"0","                of waiting times of the first patient in state t and the service time distribution. "
"0","                The resulting vector is truncated to the length of the service time distribution."""""""
"0","                if(self.parameters['x'][self.state] > 0): # Only calculate waiting times if there are patients scheduled in the state"
"0","                     logging.info(f'{datetime.datetime.now()} - Calculating w[{self.state}][0] in state {self.state}')"
"0","                     self.system['w'][self.state][0] = self.system['p_min'][self.state].copy()"
"0","                     logging.info(f'{datetime.datetime.now()} - Done')"
"0","                     for i in range(1, self.parameters['x'][self.state]):"
"0","                            logging.info(f'{datetime.datetime.now()} - Calculating w[{self.state}][{i}] in state {self.state}')"
"0","                            self.system['w'][self.state][i] = np.convolve(self.system['w'][self.state][i-1], self.parameters['s'])[:(len(self.parameters['s']))]"
"0","                            "
"0","                "
"0","                """"""The probablitity that the amount of work left in the system equals i just before state t ends equals "
"0","                the convolution of the waiting time distribution of the last arriving patient and the service time distribution. "
"0","                Unless there are no patients in the state t. In that case the distribution of total work just before t ends is equal "
"0","                to the distribution of work at the beginning of t. "
"0","                The resulting vector is truncated to the length of the service time distribution."""""""
"0","                logging.info(f'{datetime.datetime.now()} - Calculating p_plus in state {self.state}')"
"0","                self.system['p_plus'][self.state] = self.system['p_min'][self.state].copy() if self.parameters['x'][self.state] == 0 else np.convolve(self.system['w'][self.state][-1], self.parameters['s'])[:(len(self.parameters['s']))]"
"0","                """"""Jump to next state"""""""
"0","                self.state += 1"
"0","    "
"0","    def impute_compositions(self, s=0, k=2, omega=0.5):"
"0","      """""""
"0","      Impute the compositions of patients in a given time interval and establish the schedule with the lowest total waiting time."
"0","      "
"0","      Args:"
"0","      s (int): An integer representing the starting state."
"0","      k (int): An integer representing the number of states from the starting state to include in the compositions."
"0","      """""""
"0","      logging.info(f'{datetime.datetime.now()} - Running impute_compositions() in state {self.state} with x = {self.parameters[""x""]}')"
"0","      # Select the subset from the schedule for the compositions. Truncate if subset falls outside of schedule's end."
"0","      t = min(len(self.parameters['x']), s+k)"
"0","      k = t - s"
"0","      c = self.parameters['x'][s:t]"
"0","      n = c.sum()"
"0","      # Calculate initial loss"
"0","      test_wt = self.system[""ew""].sum()"
"0","      self.calculate_tardiness()"
"0","      indices = np.arange(self.system['p_min'][-1].size) "
"0","      exp_tard = (indices * self.system['p_min'][-1]).sum()"
"0","      lowest_loss = omega * test_wt / self.parameters['x'].sum() + (1 - omega) * exp_tard"
"0","      store_optim = dict({ 'x' : self.parameters['x'].copy(), 'system' : copy.deepcopy(self.system), 'tot_wt' : test_wt})"
"0","      # Generate compositions"
"0","      compositions = weak_compositions(n, k)"
"0","      logging.info(f'{datetime.datetime.now()} - Computing {len(compositions)} compositions')"
"0","      # For all compositions calculate the waiting times"
"0","      for comp in compositions:"
"0","        # Insert composition in x"
"0","        self.parameters['x'][s:t] = comp.copy()"
"0","        # Set starting state"
"0","        self.state = s"
"0","        # Adjust the array for waiting time distributions to new x"
"0","        self.system['w'][s:] = zero_arrays(self.parameters['x'][s:].copy(), len(self.parameters['s']))"
"0","        # Recalculate distributions"
"0","        # If start state is 0 reinitialize p_min, w and p_plus in state 0"
"0","        if(self.state == 0):"
"0","            self.system = dict({"
"0","                'p_min': np.zeros((len(self.parameters['x']) + 1, len(self.parameters['s'])), dtype=np.float64),"
"0","                'p_plus': np.zeros((len(self.parameters['x']), len(self.parameters['s'])), dtype=np.float64)"
"0","            })"
"0","            # Set the first element of p_min in the initial state to 1."
"0","            self.system['p_min'][0][0] = 1"
"0","            # Initialize array of arrays for saving waiting times distributions per patient"
"0","            self.system['w'] = zero_arrays(self.parameters['x'].copy(), len(self.parameters['s']))"
"0","            if(self.parameters['x'][0] > 0): # Only calculate waiting times if there are patients scheduled in the state"
"0","                     self.system['w'][0][0] = self.system['p_min'][0].copy()"
"0","                     for i in range(1, self.parameters['x'][0]):"
"0","                            self.system['w'][0][i] = np.convolve(self.system['w'][0][i-1], self.parameters['s'])[:(len(self.parameters['s']))]"
"0","            self.system['p_plus'][0] = self.system['p_min'][0].copy() if self.parameters['x'][0] == 0 else np.convolve(self.system['w'][0][-1], self.parameters['s'])[:(len(self.parameters['s']))]"
"0","            # Initialize array for saving total expected waiting times per state"
"0","            self.system['ew'] = np.zeros(len(self.parameters['x']), dtype=np.float64)"
"0","            # Set the initial state to 1."
"0","            self.state = 1"
"0","        self.calculate_system_states(until=len(self.parameters['x']))"
"0","        self.calculate_wait_times()"
"0","        test_wt = self.system[""ew""].sum()"
"0","        self.calculate_tardiness()"
"0","        indices = np.arange(self.system['p_min'][-1].size) "
"0","        exp_tard = (indices * self.system['p_min'][-1]).sum()"
"0","        test_loss = omega * test_wt / self.parameters['x'].sum() + (1 - omega) * exp_tard"
"0","        # If a composition with a lower waiting time is found, store the system"
"0","        if(test_loss < lowest_loss):"
"0","          lowest_loss = test_loss"
"0","          store_optim['x'] = self.parameters['x'].copy()"
"0","          newsystem = copy.deepcopy(self.system)"
"0","          store_optim['system'] = newsystem"
"0","          store_optim['tot_wt'] = test_wt"
"0","          logging.info(f'{datetime.datetime.now()} - Found lower loss = {lowest_loss} with x = {store_optim[""x""]} and system = {store_optim[""system""]}')"
"0","      logging.info(f'{datetime.datetime.now()} - Final result lowest loss = {lowest_loss} with x = {store_optim[""x""]} and system = {store_optim[""system""]}')"
"0","      # Set the system to the stored optimal system"
"0","      self.parameters['x'] = store_optim['x'].copy()"
"0","      self.system['p_min'] = store_optim['system']['p_min']"
"0","      self.system['p_plus'] = store_optim['system']['p_plus']"
"0","      self.system['w'] = store_optim['system']['w']"
"0","      self.system['ew'] = store_optim['system']['ew']"
"0","        "
"0","    def calculate_tardiness(self):"
"0","      """""""
"0","      Calculate the tardiness for the current system and add it as the last element to p_min - the distribution of work in interval t just before any patient has arrived. "
"0","      """""""
"0","      self.system['p_min'][-1][0] = np.sum(self.system['p_plus'][-1][:(self.parameters['d'] + 1)])"
"0","      self.system['p_min'][-1][1:(-1*self.parameters['d'])] = self.system['p_plus'][-1][(self.parameters['d'] + 1):]"
"0","      logging.info(f'{datetime.datetime.now()} - calculating tardiness distribution:  {self.system[""p_min""][-1]}')"
"0","      "
"0","    "
"0","    def search_function(self, k=1, omega=0.5):"
"0","      """""""
"0","      Slide over the schedule intervals and run inpute_compositions()"
"0","      """""""
"0","      for i in range(0, len(self.parameters['x'] - k)):"
"0","        self.impute_compositions(s=i, k=k, omega=omega)"
"0","      "
"0","      "
"0","    def calculate_wait_times(self):"
"0","      """""""
"0","      Calculate the expected waiting time for each time step."
"0","      """""""
"0","    # Initialize time counter"
"0","      t = 0"
"0","      # Calculate the expected waiting time for each time step"
"0","      for t, w in enumerate(self.system['w']):"
"0","          ew = 0"
"0","          for i in w:"
"0","              # Calculate the weighted sum of the waiting time distribution"
"0","              a = range(len(i))"
"0","              b = i"
"0","              wt = np.dot(a, b)"
"0","              ew += wt"
"0","          # Store the expected waiting time for the current time step"
"0","          self.system['ew'][t] = ew"
"0","        "
"0","        "
"0","    def visualize_state(self, state='', dist='p_plus'):"
"0","        """""""
"0","        Visualize a distribution in the last given state."
"0","        "
"0","        Args:"
"0","        state (int): An optional integer representing the state to visualize. If not provided, the current state is used."
"0","        dist (str): An optional string representing the distribution to visualize. Defaults to 'p_plus'."
"0","        """""""
"0","        if state == '':"
"0","            state = self.state"
"0","        trace = go.Scatter("
"0","            x=list(range(len(self.system[dist][state]))),"
"0","            y=self.system[dist][state],"
"0","            mode='lines'"
"0","        )"
"0","        "
"0","        data = [trace]"
"0","        "
"0","        layout = go.Layout("
"0","            title=f'{dist} in state {state} with x = {self.parameters[""x""]}<br><sub>AUR = {np.round(np.sum(self.system[dist][state]), 3)}</sub>',"
"0","            xaxis=dict(title='Time'),"
"0","            yaxis=dict(title='Probability')"
"0","        )"
"0","        "
"0","        fig = go.Figure(data=data, layout=layout)"
"0","        pyo.iplot(fig)"
"0","    "
"0","    def visualize_system(self, dist='p_plus'):"
"0","        l = len(self.parameters[""x""])"
"0","        suffix = """""
"0","        if(dist=='p_min'): suffix = f'<br>NB: p_min[{l}] contains tardiness distribution'"
"0","        """""""
"0","        Visualize a distribution for the entire system."
"0","        "
"0","        Args:"
"0","        dist (str): An optional string representing the distribution to visualize. Defaults to 'p_plus'."
"0","        """""""
"0","        values = self.system[dist]"
"0","        trace = go.Heatmap("
"0","                    z=values"
"0","                    )"
"0","        data = [trace]"
"0","        layout = go.Layout("
"0","            title=f'{dist} with x = {self.parameters[""x""]}{suffix}',"
"0","            xaxis=dict(title='Time'),"
"0","            yaxis=dict(title='Interval')"
"0","        )"
"0","        fig = go.Figure(data=data, layout=layout)"
"0","        pyo.iplot(fig)"
"0","        "
"0","    def __str__(self):"
"0","        """""""
"0","        Print all probabilities"
"0","        """""""
"0","        return(""p_min = % s \nw = % s \np_plus = % s \new = % s"" % (self.system['p_min'], self.system['w'], self.system['p_plus'], self.system['ew']))"
"0",""
