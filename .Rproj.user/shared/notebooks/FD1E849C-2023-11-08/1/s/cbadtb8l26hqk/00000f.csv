"0","def powerset(iterable):"
"0","    ""powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)"""
"0","    s = list(iterable)"
"0","    return [list(item) for item in chain.from_iterable(combinations(s, r) for r in range(len(s)+1))]"
"0","  "
"0","def get_v_star(t):"
"0","    # Create an initial vector 'u' of zeros with length 't'"
"0","    u = np.zeros(t)"
"0","    # Set the first element of vector 'u' to -1"
"0","    u[0] = -1"
"0","    # Set the last element of vector 'u' to 1"
"0","    u[-1] = 1"
"0","    # Initialize the list 'v_star' with the initial vector 'u'"
"0","    v_star = [u]"
"0","    # Loop over the length of 'u' minus one times"
"0","    for i in range(len(u) - 1):"
"0","        # Append the last element of 'u' to the front of 'u'"
"0","        u = np.append(u[-1], u)"
"0","        # Remove the last element of 'u' to maintain the same length"
"0","        u = np.delete(u, -1)"
"0","        # Append the updated vector 'u' to the list 'v_star'"
"0","        v_star.append(u)"
"0","    # Convert the list of vectors 'v_star' into a NumPy array and return it"
"0","    return(np.array(v_star))"
"0","    "
"0","# Example of function call:"
"0","# This will create a 4x4 matrix where each row is a cyclically shifted version of the first row"
"0",""
"0","def generate_search_neighborhood(schedule):"
"0","  N = sum(schedule)"
"0","  T = len(schedule)"
"0","  print(f'The schedule = {schedule}')"
"0","  "
"0","  # Generate a matrix 'v_star' using the 'get_v_star' function"
"0","  v_star = get_v_star(T)"
"0","  "
"0","  # Generate all possible non-empty subsets (powerset) of the set {0, 1, 2, ..., T-1}"
"0","  # 'ids' will be a list of tuples, where each tuple is a subset of indices"
"0","  ids = list(powerset(range(T)))"
"0","  "
"0","  # Select the vectors from 'v_star' that correspond to the indices in each subset"
"0","  # 'sub_sets' will be a list of lists, where each inner list contains vectors from 'v_star'"
"0","  sub_sets = [v_star[i] for i in ids]"
"0","  "
"0","  # Sum the vectors within each subset and flatten the result to get a 1-D array"
"0","  # 'summed_sets' will be a list of 1-D numpy arrays, where each array is the sum of vectors"
"0","  summed_sets = [np.sum(sub_sets[i], axis=0).flatten() for i in range(len(sub_sets))]"
"0","  "
"0","  neighborhood = np.array([schedule + summed_sets[i] for i in range(len(summed_sets))])"
"0","  "
"0","  # Create a mask for rows with negative values"
"0","  mask = ~np.any(neighborhood < 0, axis=1)"
"0","  "
"0","  # Filter out rows with negative values using the mask"
"0","  filtered_neighborhood = neighborhood[mask]"
"0","  print(f'And the neighborhood is {filtered_neighborhood}')"
"0","  return filtered_neighborhood"
"0","  "
"0","def obj_function(x):"
"0","  res = sum(map(lambda i: i * i, x))"
"0","  return res"
"0","  "
"0","def split_coordinates(array):"
"0","    """""""
"0","    Splits a numpy array of coordinates into separate vectors for x, y, and z."
"0","    "
"0","    Parameters:"
"0","    array (numpy.ndarray): A numpy array where each row represents a set of coordinates (x, y, z)."
"0","    "
"0","    Returns:"
"0","    tuple: Three lists containing the x, y, and z coordinates, respectively."
"0","    """""""
"0","    x = array[:, 0]"
"0","    y = array[:, 1]"
"0","    z = array[:, 2]"
"0","    return x.tolist(), y.tolist(), z.tolist()"
"0","    "
"0","x = [3, 0, 0]"
"0","testnh = generate_search_neighborhood(x)"
"1","The schedule = [3, 0, 0]
And the neighborhood is [[3. 0. 0.]
 [2. 0. 1.]
 [2. 1. 0.]
 [3. 0. 0.]]
"
"0","f_x = [obj_function(s) for s in testnh]"
"0","x, y, z = split_coordinates(testnh)"
"0","print(x, y, z, f_x)"
"1","[3.0, 2.0, 2.0, 3.0] [0.0, 0.0, 1.0, 0.0] [0.0, 1.0, 0.0, 0.0] [9.0, 5.0, 5.0, 9.0]
"
